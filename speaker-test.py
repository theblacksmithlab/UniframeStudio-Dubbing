#!/usr/bin/env python3
"""
–ë–∞–∑–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è speaker diarization
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç PyAnnote.audio –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–ø–∏–∫–µ—Ä–æ–≤ –≤ –∞—É–¥–∏–æ —Ñ–∞–π–ª–µ
"""

import json
import sys
from pathlib import Path
import argparse


def install_requirements():
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π"""
    import subprocess

    packages = [
        "pyannote.audio",
        "torch",
        "torchaudio"
    ]

    for package in packages:
        try:
            __import__(package.replace("-", "_"))
            print(f"‚úì {package} —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        except ImportError:
            print(f"–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é {package}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])


def test_diarization(audio_path: str, output_path: str = None, hf_token: str = None):
    """
    –¢–µ—Å—Ç–∏—Ä—É–µ—Ç speaker diarization –Ω–∞ –∞—É–¥–∏–æ —Ñ–∞–π–ª–µ

    Args:
        audio_path: –ø—É—Ç—å –∫ –∞—É–¥–∏–æ —Ñ–∞–π–ª—É
        output_path: –ø—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        hf_token: HuggingFace —Ç–æ–∫–µ–Ω –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –º–æ–¥–µ–ª—è–º
    """
    try:
        from pyannote.audio import Pipeline
        import torch

        print(f"üéµ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ: {audio_path}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞
        if not Path(audio_path).exists():
            raise FileNotFoundError(f"–ê—É–¥–∏–æ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {audio_path}")

        # –°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –¥–ª—è –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏
        models_to_try = [
            "pyannote/speaker-diarization-3.1",
            "pyannote/speaker-diarization",
            "pyannote/speaker-diarization-3.0"
        ]

        pipeline = None
        for model_name in models_to_try:
            try:
                print(f"üì• –ü—Ä–æ–±—É—é –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å: {model_name}")
                pipeline = Pipeline.from_pretrained(
                    model_name,
                    use_auth_token=hf_token
                )
                print(f"‚úÖ –ú–æ–¥–µ–ª—å {model_name} –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
                break
            except Exception as e:
                print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å {model_name}: {e}")
                continue

        if pipeline is None:
            print("\nüîë –í—Å–µ –º–æ–¥–µ–ª–∏ —Ç—Ä–µ–±—É—é—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏!")
            print("–°–æ–∑–¥–∞–π—Ç–µ —Ç–æ–∫–µ–Ω –Ω–∞ https://huggingface.co/settings/tokens")
            print("–ò –ø—Ä–∏–º–∏—Ç–µ —É—Å–ª–æ–≤–∏—è –Ω–∞ https://huggingface.co/pyannote/speaker-diarization-3.1")
            print("–ó–∞—Ç–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç–µ: python speaker-test.py audio.wav --token YOUR_TOKEN")
            return None

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º GPU –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        pipeline = pipeline.to(device)
        print(f"üîß –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device}")

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞—É–¥–∏–æ
        print("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–ø–∏–∫–µ—Ä–æ–≤...")
        diarization = pipeline(audio_path)

        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —É–¥–æ–±–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        speakers_timeline = []
        for turn, _, speaker in diarization.itertracks(yield_label=True):
            speakers_timeline.append({
                "start": float(turn.start),
                "end": float(turn.end),
                "speaker": speaker,
                "duration": float(turn.end - turn.start)
            })

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
        speakers_timeline.sort(key=lambda x: x["start"])

        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result = {
            "total_duration": max([s["end"] for s in speakers_timeline]) if speakers_timeline else 0,
            "speakers_count": len(set([s["speaker"] for s in speakers_timeline])),
            "speakers_found": list(set([s["speaker"] for s in speakers_timeline])),
            "timeline": speakers_timeline
        }

        # –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        print("\n" + "=" * 50)
        print("üìä –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ê–ù–ê–õ–ò–ó–ê –°–ü–ò–ö–ï–†–û–í")
        print("=" * 50)
        print(f"–û–±—â–∞—è –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {result['total_duration']:.2f} —Å–µ–∫")
        print(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∏–∫–µ—Ä–æ–≤: {result['speakers_count']}")
        print(f"–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å–ø–∏–∫–µ—Ä—ã: {', '.join(result['speakers_found'])}")
        print("\nüìã –í—Ä–µ–º–µ–Ω–Ω–∞—è —Ä–∞–∑–º–µ—Ç–∫–∞:")

        for i, segment in enumerate(speakers_timeline[:10]):  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 10
            print(f"  {i + 1:2d}. {segment['start']:6.2f}s - {segment['end']:6.2f}s "
                  f"({segment['duration']:5.2f}s) | {segment['speaker']}")

        if len(speakers_timeline) > 10:
            print(f"  ... –∏ –µ—â—ë {len(speakers_timeline) - 10} —Å–µ–≥–º–µ–Ω—Ç–æ–≤")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ñ–∞–π–ª
        if output_path:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            print(f"\nüíæ –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤: {output_path}")

        return result

    except ImportError as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}")
        print("–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:")
        print("pip install pyannote.audio torch torchaudio")
        return None

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(description="–¢–µ—Å—Ç speaker diarization")
    parser.add_argument("audio_path", help="–ü—É—Ç—å –∫ –∞—É–¥–∏–æ —Ñ–∞–π–ª—É")
    parser.add_argument("-o", "--output", help="–ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è JSON —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞")
    parser.add_argument("--token", help="HuggingFace —Ç–æ–∫–µ–Ω –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏")
    parser.add_argument("--install", action="store_true", help="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏")

    args = parser.parse_args()

    if args.install:
        install_requirements()
        return

    # –¢–µ—Å—Ç–∏—Ä—É–µ–º diarization
    result = test_diarization(args.audio_path, args.output, args.token)

    if result:
        print("\n‚úÖ –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ!")
        print("\n–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ –≤ –≤–∞—à python-dubbing-service")
    else:
        print("\n‚ùå –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —Å –æ—à–∏–±–∫–æ–π")


if __name__ == "__main__":
    main()